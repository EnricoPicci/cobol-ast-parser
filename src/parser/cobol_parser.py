"""COBOL parser wrapper using ANTLR4.

This module provides a high-level interface to the ANTLR4-generated
COBOL parser. It handles:
- Lexer and parser instantiation
- Error handling and reporting
- Parse tree generation
"""

from typing import Optional, List, Any, Tuple
from dataclasses import dataclass, field
from pathlib import Path
import bisect
import re
import sys


class ParseError(Exception):
    """Error during COBOL parsing."""

    def __init__(self, message: str, line: int = 0, column: int = 0):
        self.line = line
        self.column = column
        super().__init__(f"Line {line}:{column} - {message}")


@dataclass
class ParseErrorInfo:
    """Information about a parse error."""

    message: str
    line: int
    column: int
    offending_symbol: Optional[str] = None


class CobolErrorListener:
    """Custom error listener for COBOL parsing."""

    def __init__(self):
        self.errors: List[ParseErrorInfo] = []

    def syntaxError(
        self,
        recognizer,
        offendingSymbol,
        line: int,
        column: int,
        msg: str,
        e,
    ):
        """Record a syntax error."""
        symbol_text = str(offendingSymbol) if offendingSymbol else None
        self.errors.append(
            ParseErrorInfo(
                message=msg,
                line=line,
                column=column,
                offending_symbol=symbol_text,
            )
        )

    def reportAmbiguity(self, *args, **kwargs):
        """Handle ambiguity reports (ignored)."""
        pass

    def reportAttemptingFullContext(self, *args, **kwargs):
        """Handle full context attempts (ignored)."""
        pass

    def reportContextSensitivity(self, *args, **kwargs):
        """Handle context sensitivity reports (ignored)."""
        pass

    def has_errors(self) -> bool:
        """Check if any errors were recorded."""
        return len(self.errors) > 0


class CobolParser:
    """High-level COBOL parser interface.

    This class wraps the ANTLR4-generated parser to provide a cleaner
    interface for parsing COBOL source code.
    """

    def __init__(self, use_generated: bool = True):
        """Initialize the COBOL parser.

        Args:
            use_generated: Whether to use ANTLR4-generated parser (requires generated files)
        """
        self.use_generated = use_generated
        self._parser = None
        self._lexer = None
        self._error_listener = None

        if use_generated:
            self._import_generated_parser()

    def _import_generated_parser(self):
        """Import the ANTLR4-generated parser classes."""
        try:
            # Try to import ANTLR4 runtime
            from antlr4 import CommonTokenStream, InputStream

            # Try to import generated parser files
            # These would be generated by running ANTLR4 on the grammar
            try:
                from .generated.Cobol85Lexer import Cobol85Lexer
                from .generated.Cobol85Parser import Cobol85Parser

                self._lexer_class = Cobol85Lexer
                self._parser_class = Cobol85Parser
                self._antlr_available = True
            except ImportError:
                # Generated files not yet created
                self._antlr_available = False

        except ImportError:
            # ANTLR4 runtime not installed
            self._antlr_available = False

    def parse(self, source: str) -> Any:
        """Parse COBOL source code.

        Args:
            source: COBOL source code string

        Returns:
            Parse tree (StartRuleContext) if using ANTLR4,
            or a simplified representation otherwise

        Raises:
            ParseError: If parsing fails
        """
        if (
            self.use_generated
            and hasattr(self, "_antlr_available")
            and self._antlr_available
        ):
            return self._parse_with_antlr(source)
        else:
            return self._parse_simplified(source)

    def _parse_with_antlr(self, source: str) -> Any:
        """Parse using ANTLR4-generated parser."""
        from antlr4 import CommonTokenStream, InputStream

        # Create input stream
        input_stream = InputStream(source)

        # Create lexer
        lexer = self._lexer_class(input_stream)
        lexer.removeErrorListeners()
        self._error_listener = CobolErrorListener()
        lexer.addErrorListener(self._error_listener)

        # Create token stream
        token_stream = CommonTokenStream(lexer)

        # Create parser
        parser = self._parser_class(token_stream)
        parser.removeErrorListeners()
        parser.addErrorListener(self._error_listener)

        # Parse starting from the start rule
        tree = parser.startRule()

        # Check for errors
        if self._error_listener.has_errors():
            first_error = self._error_listener.errors[0]
            raise ParseError(
                first_error.message,
                first_error.line,
                first_error.column,
            )

        return tree

    def _parse_simplified(self, source: str) -> "SimplifiedParseTree":
        """Parse using a simplified regex-based parser.

        This is a fallback when ANTLR4 is not available.
        It provides basic structure extraction.
        """
        return SimplifiedCobolParser().parse(source)

    def get_errors(self) -> List[ParseErrorInfo]:
        """Get list of parse errors.

        Returns:
            List of ParseErrorInfo objects
        """
        if self._error_listener:
            return self._error_listener.errors
        return []

    def parse_file(self, filepath: Path) -> Any:
        """Parse a COBOL file.

        Args:
            filepath: Path to the COBOL file

        Returns:
            Parse tree

        Raises:
            ParseError: If parsing fails
            FileNotFoundError: If file doesn't exist
        """
        source = filepath.read_text(encoding="utf-8", errors="replace")
        return self.parse(source)


@dataclass
class SimplifiedParseTree:
    """Simplified parse tree for use without ANTLR4."""

    program_name: str = ""
    identification_division: dict = field(default_factory=dict)
    environment_division: dict = field(default_factory=dict)
    data_division: "SimplifiedDataDivision" = field(
        default_factory=lambda: SimplifiedDataDivision()
    )
    procedure_division: "SimplifiedProcedureDivision" = field(
        default_factory=lambda: SimplifiedProcedureDivision()
    )
    source_lines: List[str] = field(default_factory=list)


@dataclass
class SimplifiedDataDivision:
    """Simplified data division representation."""

    working_storage: List["SimplifiedDataItem"] = field(default_factory=list)
    file_section: List["SimplifiedDataItem"] = field(default_factory=list)
    linkage_section: List["SimplifiedDataItem"] = field(default_factory=list)
    local_storage: List["SimplifiedDataItem"] = field(default_factory=list)


@dataclass
class SimplifiedDataItem:
    """Simplified data item representation."""

    level: int
    name: str
    picture: Optional[str] = None
    redefines: Optional[str] = None
    occurs: Optional[int] = None
    value: Optional[str] = None
    line_number: int = 0
    is_filler: bool = False


@dataclass
class SimplifiedProcedureDivision:
    """Simplified procedure division representation.

    Attributes:
        sections: List of sections in the procedure division.
        paragraphs: List of top-level paragraphs (not inside any section).
        orphan_statements: Statements that appear before any paragraph or section
            in the PROCEDURE DIVISION. These are typically initialization statements.
    """

    sections: List["SimplifiedSection"] = field(default_factory=list)
    paragraphs: List["SimplifiedParagraph"] = field(default_factory=list)
    orphan_statements: List["SimplifiedStatement"] = field(default_factory=list)


@dataclass
class SimplifiedSection:
    """Simplified section representation."""

    name: str
    paragraphs: List["SimplifiedParagraph"] = field(default_factory=list)
    statements: List["SimplifiedStatement"] = field(default_factory=list)
    line_number: int = 0


@dataclass
class SimplifiedParagraph:
    """Simplified paragraph representation."""

    name: str
    statements: List["SimplifiedStatement"] = field(default_factory=list)
    line_number: int = 0


@dataclass
class SimplifiedStatement:
    """Simplified statement representation."""

    statement_type: str
    text: str
    targets: List[str] = field(default_factory=list)  # Variables modified
    sources: List[str] = field(default_factory=list)  # Variables read
    line_number: int = 0


class SimplifiedCobolParser:
    """Simplified COBOL parser using regex patterns.

    This parser provides basic structure extraction without requiring
    ANTLR4. It's useful for testing and environments where ANTLR4
    cannot be installed.
    """

    # COBOL keywords that should not be captured as variable names
    COBOL_KEYWORDS = {
        # Data movement
        "MOVE",
        "TO",
        "FROM",
        "CORRESPONDING",
        "CORR",
        # Arithmetic
        "ADD",
        "SUBTRACT",
        "MULTIPLY",
        "DIVIDE",
        "COMPUTE",
        "GIVING",
        "REMAINDER",
        "ROUNDED",
        "BY",
        "INTO",
        # Control flow
        "PERFORM",
        "VARYING",
        "UNTIL",
        "TIMES",
        "THRU",
        "THROUGH",
        "IF",
        "ELSE",
        "END-IF",
        "THEN",
        "NOT",
        "AND",
        "OR",
        "EVALUATE",
        "WHEN",
        "OTHER",
        "END-EVALUATE",
        "GO",
        "GOTO",
        # I/O
        "DISPLAY",
        "ACCEPT",
        "READ",
        "WRITE",
        "REWRITE",
        "DELETE",
        "OPEN",
        "CLOSE",
        "START",
        "STOP",
        "RUN",
        # File handling
        "INPUT",
        "OUTPUT",
        "I-O",
        "EXTEND",
        # Procedure
        "CALL",
        "USING",
        "RETURNING",
        "ON",
        "SIZE",
        "ERROR",
        "OVERFLOW",
        "EXCEPTION",
        # String handling
        "STRING",
        "UNSTRING",
        "INSPECT",
        "TALLYING",
        "REPLACING",
        "CONVERTING",
        "DELIMITED",
        "POINTER",
        "COUNT",
        # Data manipulation
        "SET",
        "TRUE",
        "FALSE",
        "SEARCH",
        "ALL",
        "AT",
        "END",
        "INITIALIZE",
        "WITH",
        "FILLER",
        # Conditionals
        "NUMERIC",
        "ALPHABETIC",
        "ALPHABETIC-LOWER",
        "ALPHABETIC-UPPER",
        "POSITIVE",
        "NEGATIVE",
        "ZERO",
        "ZEROS",
        "ZEROES",
        "SPACE",
        "SPACES",
        "HIGH-VALUE",
        "HIGH-VALUES",
        "LOW-VALUE",
        "LOW-VALUES",
        "QUOTE",
        "QUOTES",
        # Misc
        "CONTINUE",
        "EXIT",
        "NEXT",
        "SENTENCE",
        "AFTER",
        "BEFORE",
        "INITIAL",
        "REFERENCE",
        "CONTENT",
        "VALUE",
    }

    # Figurative constants (class attribute to avoid recreating set on every call)
    FIGURATIVE_CONSTANTS = {
        "ZERO",
        "ZEROS",
        "ZEROES",
        "SPACE",
        "SPACES",
        "HIGH-VALUE",
        "HIGH-VALUES",
        "LOW-VALUE",
        "LOW-VALUES",
        "QUOTE",
        "QUOTES",
        "NULL",
        "NULLS",
        "ALL",
        "TRUE",
        "FALSE",
    }

    # Pre-compiled patterns for variable extraction (avoid recompilation per call)
    VARIABLE_PATTERN = re.compile(r"\b([A-Za-z][A-Za-z0-9-]*)\b")
    VARIABLE_WITH_SUBSCRIPT_PATTERN = re.compile(
        r"([A-Za-z][A-Za-z0-9-]*)\s*(?:\(([^)]+)\))?"
    )
    STRING_LITERAL_PATTERN = re.compile(r'"[^"]*"|\'[^\']*\'')

    # Division patterns
    IDENTIFICATION_DIVISION = re.compile(
        r"IDENTIFICATION\s+DIVISION\s*\.", re.IGNORECASE
    )
    ENVIRONMENT_DIVISION = re.compile(r"ENVIRONMENT\s+DIVISION\s*\.", re.IGNORECASE)
    DATA_DIVISION = re.compile(r"DATA\s+DIVISION\s*\.", re.IGNORECASE)
    PROCEDURE_DIVISION = re.compile(r"PROCEDURE\s+DIVISION[^.]*\.", re.IGNORECASE)

    # Section patterns
    WORKING_STORAGE = re.compile(r"WORKING-STORAGE\s+SECTION\s*\.", re.IGNORECASE)
    FILE_SECTION = re.compile(r"FILE\s+SECTION\s*\.", re.IGNORECASE)
    LINKAGE_SECTION = re.compile(r"LINKAGE\s+SECTION\s*\.", re.IGNORECASE)
    LOCAL_STORAGE = re.compile(r"LOCAL-STORAGE\s+SECTION\s*\.", re.IGNORECASE)

    # Data item pattern - supports clauses in any order
    # COBOL allows: REDEFINES, PIC, OCCURS, VALUE, USAGE in various orders
    # Use [ \t]* instead of \s* at start to avoid matching across lines
    DATA_ITEM = re.compile(
        r"^[ \t]*(\d{1,2})\s+"  # Level number (only match horizontal whitespace at start)
        r"([A-Za-z0-9][-A-Za-z0-9]*)"  # Data name
        r"((?:\s+(?:"
        r"REDEFINES\s+[A-Za-z0-9][-A-Za-z0-9]*"  # REDEFINES clause
        r"|PIC(?:TURE)?\s+(?:IS\s+)?[^\s.]+"  # PICTURE clause
        r"|OCCURS\s+\d+(?:\s+TIMES)?"  # OCCURS clause (with optional TIMES)
        r"|VALUE\s+(?:IS\s+)?[^.]*?"  # VALUE clause
        r"|USAGE\s+(?:IS\s+)?[A-Za-z0-9-]+"  # USAGE clause
        r"|COMP(?:-[0-9])?"  # COMP shorthand
        r"|BINARY"  # BINARY
        r"|PACKED-DECIMAL"  # PACKED-DECIMAL
        r"|DISPLAY"  # DISPLAY
        r"))*)"  # End of clauses group
        r"\s*\.",
        re.IGNORECASE | re.MULTILINE,
    )

    # Program-ID pattern
    PROGRAM_ID = re.compile(
        r"PROGRAM-ID\s*\.\s*([A-Za-z0-9][-A-Za-z0-9]*)", re.IGNORECASE
    )

    # Section/Paragraph patterns in procedure division
    # In COBOL fixed format, Area A is columns 8-11 (about 7 leading spaces after
    # sequence number area). We allow 0-12 leading spaces to be conservative.
    # This prevents matching multi-line statement continuations (38+ spaces) as headers.
    SECTION_HEADER = re.compile(
        r"^[ ]{0,12}([A-Za-z0-9][-A-Za-z0-9]*)\s+SECTION\s*\.", re.IGNORECASE | re.MULTILINE
    )
    # Paragraph header pattern - also excludes COBOL structure terminators
    # (END-*, WHEN, OTHER) which appear on their own lines but are not paragraphs
    PARAGRAPH_HEADER = re.compile(
        r"^[ ]{0,12}(?!END-|WHEN\s|OTHER\s)([A-Za-z0-9][-A-Za-z0-9]*)\s*\.\s*$",
        re.IGNORECASE | re.MULTILINE,
    )

    # Statement patterns (for modification tracking)
    # Variable name pattern - excludes COBOL keywords via negative lookahead
    # This prevents capturing keywords like MOVE, ADD, TO as variable names
    _VAR_NAME = (
        r"(?!(?:MOVE|COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE|PERFORM|IF|ELSE|THEN|"
        r"END-IF|END-PERFORM|END-EVALUATE|END-CALL|DISPLAY|STOP|GO|GOBACK|CALL|"
        r"TO|FROM|INTO|BY|GIVING|USING|RETURNING|READ|WRITE|OPEN|CLOSE|"
        r"INITIALIZE|SET|STRING|UNSTRING|INSPECT|ACCEPT|RETURN|SEARCH|EVALUATE|"
        r"EXIT|CONTINUE|WHEN|WITH|NOT|ON|AT|AFTER|BEFORE|UPON|REPLACING|"
        r"TALLYING|DELIMITED|POINTER|OVERFLOW|SIZE|ERROR|INVALID|END|"
        r"WORKING-STORAGE|LINKAGE|FILE|PROCEDURE|DATA|IDENTIFICATION)\b)"
        r"[A-Za-z0-9][-A-Za-z0-9]*"
    )
    # Terminator pattern - stops at period or newline followed by COBOL statement keyword
    _STMT_TERM = (
        r"(?:\s*\.|"
        r"(?=\s*\n\s*(?:MOVE|COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE|PERFORM|IF|"
        r"DISPLAY|CALL|GO|GOBACK|STOP|READ|WRITE|OPEN|CLOSE|INITIALIZE|SET|"
        r"STRING|UNSTRING|INSPECT|ACCEPT|RETURN|SEARCH|EVALUATE|EXIT|CONTINUE)\b))"
    )
    # MOVE pattern - supports multi-line targets with period termination
    # or single-line targets terminated by next statement keyword
    MOVE_STMT = re.compile(
        rf"\bMOVE\s+(.+?)\s+TO\s+({_VAR_NAME}(?:\s*\([^)]+\))?(?:[\s,]+{_VAR_NAME}(?:\s*\([^)]+\))?)*){_STMT_TERM}",
        re.IGNORECASE | re.DOTALL,
    )
    COMPUTE_STMT = re.compile(
        r"\bCOMPUTE\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)\s*=\s*([^.]+)",
        re.IGNORECASE,
    )
    ADD_STMT = re.compile(
        r"\bADD\s+(.+?)\s+TO\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    SUBTRACT_STMT = re.compile(
        r"\bSUBTRACT\s+(.+?)\s+FROM\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    MULTIPLY_STMT = re.compile(
        r"\bMULTIPLY\s+(.+?)\s+BY\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    DIVIDE_STMT = re.compile(
        r"\bDIVIDE\s+(.+?)\s+(?:INTO|BY)\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    ACCEPT_STMT = re.compile(
        r"\bACCEPT\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    READ_STMT = re.compile(
        r"\bREAD\s+([A-Za-z0-9][-A-Za-z0-9]*)\s+INTO\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    # INITIALIZE pattern - supports multi-line targets
    # Terminates at period, REPLACING/WITH clauses, or next statement keyword
    _INIT_TERM = (
        r"(?:\s*\.|"
        r"(?=\s+(?:REPLACING|WITH)\b)|"
        r"(?=\s*\n\s*(?:MOVE|COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE|PERFORM|IF|"
        r"DISPLAY|CALL|GO|GOBACK|STOP|READ|WRITE|OPEN|CLOSE|INITIALIZE|SET|"
        r"STRING|UNSTRING|INSPECT|ACCEPT|RETURN|SEARCH|EVALUATE|EXIT|CONTINUE)\b))"
    )
    INITIALIZE_STMT = re.compile(
        rf"\bINITIALIZE\s+({_VAR_NAME}(?:\s*\([^)]+\))?(?:[\s,]+{_VAR_NAME}(?:\s*\([^)]+\))?)*){_INIT_TERM}",
        re.IGNORECASE | re.DOTALL,
    )
    SET_STMT = re.compile(
        r"\bSET\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)\s+TO\s+",
        re.IGNORECASE,
    )
    STRING_STMT = re.compile(
        r"\bSTRING\s+.+?\s+INTO\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE | re.DOTALL,
    )
    # UNSTRING pattern - supports multi-line targets after INTO
    # Terminates at period, POINTER/TALLYING/OVERFLOW clauses, or next statement keyword
    _UNSTR_TERM = (
        r"(?:\s*\.|"
        r"(?=\s+(?:WITH|POINTER|TALLYING|ON\s+OVERFLOW|NOT\s+ON|END-UNSTRING|DELIMITER)\b)|"
        r"(?=\s*\n\s*(?:MOVE|COMPUTE|ADD|SUBTRACT|MULTIPLY|DIVIDE|PERFORM|IF|"
        r"DISPLAY|CALL|GO|GOBACK|STOP|READ|WRITE|OPEN|CLOSE|INITIALIZE|SET|"
        r"STRING|UNSTRING|INSPECT|ACCEPT|RETURN|SEARCH|EVALUATE|EXIT|CONTINUE)\b))"
    )
    UNSTRING_STMT = re.compile(
        rf"\bUNSTRING\s+.+?\s+INTO\s+({_VAR_NAME}(?:\s*\([^)]+\))?(?:[\s,]+{_VAR_NAME}(?:\s*\([^)]+\))?)*){_UNSTR_TERM}",
        re.IGNORECASE | re.DOTALL,
    )
    INSPECT_STMT = re.compile(
        r"\bINSPECT\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)\s+(?:TALLYING|REPLACING|CONVERTING)",
        re.IGNORECASE,
    )

    # Arithmetic with GIVING clause - ADD A TO B GIVING C (C is target, A and B are sources)
    ADD_GIVING_STMT = re.compile(
        r"\bADD\s+(.+?)\s+(?:TO\s+(.+?)\s+)?GIVING\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    SUBTRACT_GIVING_STMT = re.compile(
        r"\bSUBTRACT\s+(.+?)\s+FROM\s+(.+?)\s+GIVING\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    MULTIPLY_GIVING_STMT = re.compile(
        r"\bMULTIPLY\s+(.+?)\s+BY\s+(.+?)\s+GIVING\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    DIVIDE_GIVING_STMT = re.compile(
        r"\bDIVIDE\s+(.+?)\s+(?:INTO|BY)\s+(.+?)\s+GIVING\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)"
        r"(?:\s+REMAINDER\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?))?",
        re.IGNORECASE,
    )

    # WRITE FROM and REWRITE FROM - FROM variable is read
    WRITE_FROM_STMT = re.compile(
        r"\bWRITE\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)\s+FROM\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    REWRITE_FROM_STMT = re.compile(
        r"\bREWRITE\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)\s+FROM\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )

    # RETURN INTO - similar to READ INTO for SORT processing
    RETURN_INTO_STMT = re.compile(
        r"\bRETURN\s+([A-Za-z0-9][-A-Za-z0-9]*)\s+INTO\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )

    # MOVE CORRESPONDING / MOVE CORR - moves matching fields between group items
    MOVE_CORR_STMT = re.compile(
        r"\bMOVE\s+(?:CORRESPONDING|CORR)\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)\s+TO\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )

    # Patterns for statements that read variables (access tracking)
    # DISPLAY can have literals and variables mixed, we'll extract variables from the full match
    # Note: re.MULTILINE is required so $ matches end-of-line, not just end-of-string
    DISPLAY_STMT = re.compile(
        r"\bDISPLAY\s+(.+?)(?:\s*\.|\s+(?:WITH|UPON|NO|END-DISPLAY)|\s*$)",
        re.IGNORECASE | re.MULTILINE,
    )
    IF_CONDITION = re.compile(
        r"\bIF\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    EVALUATE_STMT = re.compile(
        r"\bEVALUATE\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)",
        re.IGNORECASE,
    )
    PERFORM_UNTIL = re.compile(
        r"\bPERFORM\s+[A-Za-z0-9][-A-Za-z0-9]*\s+(?:THRU|THROUGH\s+[A-Za-z0-9][-A-Za-z0-9]*\s+)?(?:VARYING\s+[A-Za-z0-9][-A-Za-z0-9]*\s+FROM\s+)?(?:UNTIL\s+)?([A-Za-z0-9][-A-Za-z0-9]*)",
        re.IGNORECASE,
    )

    # PERFORM VARYING pattern - simplified termination
    PERFORM_VARYING_STMT = re.compile(
        r"\bPERFORM\s+(?:[A-Za-z0-9][-A-Za-z0-9]*(?:\s+(?:THRU|THROUGH)\s+[A-Za-z0-9][-A-Za-z0-9]*)?\s+)?"
        r"VARYING\s+([A-Za-z0-9][-A-Za-z0-9]*(?:\s*\([^)]+\))?)"
        r"\s+FROM\s+([^\s]+(?:\s*\([^)]+\))?)"
        r"\s+BY\s+([^\s]+(?:\s*\([^)]+\))?)"
        r"(?:\s+UNTIL\s+([^\n.]+?))?(?=\s*(?:\.|\bEND-PERFORM\b|\bPERFORM\b|\bMOVE\b|\bIF\b|\bDISPLAY\b|\bCOMPUTE\b|\bCALL\b))",
        re.IGNORECASE | re.DOTALL,
    )

    # CALL USING pattern - simplified termination
    CALL_STMT = re.compile(
        r"\bCALL\s+(?:[A-Za-z0-9][-A-Za-z0-9]*|'[^']+'|\"[^\"]+\")"
        r"\s+USING\s+([^.]+?)(?=\s*(?:\.|\bEND-CALL\b|\bON\s+EXCEPTION\b|\bNOT\s+ON\b)|\n\s*[A-Z])",
        re.IGNORECASE | re.DOTALL,
    )

    # IF full condition pattern - simplified with consolidated keyword check
    IF_FULL_CONDITION = re.compile(
        r"\bIF\s+([^.]+?)(?=\s*(?:\bTHEN\b|\bPERFORM\b|\bMOVE\b|\bCOMPUTE\b|\bADD\b|\bSUBTRACT\b|\bDISPLAY\b|\bCALL\b|\bSET\b|\bGO\b|\bEVALUATE\b|\bSTRING\b|\bNEXT\s+SENTENCE\b|\bEND-IF\b|\.)|\n\s*[A-Z])",
        re.IGNORECASE | re.DOTALL,
    )

    # EVALUATE full pattern - captures subject up to first WHEN (avoids nested quantifier backtracking)
    EVALUATE_FULL_STMT = re.compile(
        r"\bEVALUATE\s+([^.]+?)(?=\s*\bWHEN\b)",
        re.IGNORECASE | re.DOTALL,
    )

    # EVALUATE WHEN clause pattern - simplified to avoid excessive alternations
    EVALUATE_WHEN_CLAUSE = re.compile(
        r"\bWHEN\s+([^.]+?)(?=\s*(?:\bWHEN\b|\bEND-EVALUATE\b|\bMOVE\b|\bPERFORM\b|\bDISPLAY\b|\bCOMPUTE\b|\bSET\b|\bCALL\b|\bSTRING\b|\bGO\b|\.))",
        re.IGNORECASE | re.DOTALL,
    )

    # Pattern to find EVALUATE block end for extracting all WHEN clauses
    EVALUATE_BLOCK_END = re.compile(
        r"\bEND-EVALUATE\b|\.\s*$|\.\s*\n",
        re.IGNORECASE | re.MULTILINE,
    )

    def parse(self, source: str) -> SimplifiedParseTree:
        """Parse COBOL source into a simplified parse tree.

        Args:
            source: COBOL source code

        Returns:
            SimplifiedParseTree object
        """
        tree = SimplifiedParseTree()
        tree.source_lines = source.splitlines()

        # Extract program name
        match = self.PROGRAM_ID.search(source)
        if match:
            tree.program_name = match.group(1).upper()

        # Find division boundaries
        divisions = self._find_division_boundaries(source)

        # Parse data division
        if "data" in divisions:
            data_start, data_end = divisions["data"]
            data_source = source[data_start:data_end]
            tree.data_division = self._parse_data_division(
                data_source, data_start, tree.source_lines
            )

        # Parse procedure division
        if "procedure" in divisions:
            proc_start, proc_end = divisions["procedure"]
            proc_source = source[proc_start:proc_end]
            tree.procedure_division = self._parse_procedure_division(
                proc_source, proc_start, tree.source_lines
            )

        return tree

    def _find_division_boundaries(self, source: str) -> dict:
        """Find the start and end positions of each division."""
        divisions = {}
        source_upper = source.upper()

        # Find all division starts
        div_positions = []

        for pattern, name in [
            (self.IDENTIFICATION_DIVISION, "identification"),
            (self.ENVIRONMENT_DIVISION, "environment"),
            (self.DATA_DIVISION, "data"),
            (self.PROCEDURE_DIVISION, "procedure"),
        ]:
            match = pattern.search(source)
            if match:
                div_positions.append((match.start(), name))

        # Sort by position
        div_positions.sort(key=lambda x: x[0])

        # Calculate boundaries
        for i, (pos, name) in enumerate(div_positions):
            if i + 1 < len(div_positions):
                end = div_positions[i + 1][0]
            else:
                end = len(source)
            divisions[name] = (pos, end)

        return divisions

    def _parse_data_division(
        self, source: str, offset: int, all_lines: List[str]
    ) -> SimplifiedDataDivision:
        """Parse the DATA DIVISION."""
        data_div = SimplifiedDataDivision()

        # Find section boundaries within data division
        sections = {
            "working_storage": (self.WORKING_STORAGE, data_div.working_storage),
            "file_section": (self.FILE_SECTION, data_div.file_section),
            "linkage_section": (self.LINKAGE_SECTION, data_div.linkage_section),
            "local_storage": (self.LOCAL_STORAGE, data_div.local_storage),
        }

        section_positions = []
        for name, (pattern, _) in sections.items():
            match = pattern.search(source)
            if match:
                section_positions.append((match.end(), name))

        section_positions.sort(key=lambda x: x[0])

        # Parse each section
        for i, (start_pos, section_name) in enumerate(section_positions):
            if i + 1 < len(section_positions):
                end_pos = section_positions[i + 1][0]
            else:
                end_pos = len(source)

            section_source = source[start_pos:end_pos]
            items = self._parse_data_items(
                section_source, offset + start_pos, all_lines
            )
            sections[section_name][1].extend(items)

        return data_div

    # Helper patterns for extracting individual clauses
    REDEFINES_EXTRACT = re.compile(
        r"\bREDEFINES\s+([A-Za-z0-9][-A-Za-z0-9]*)", re.IGNORECASE
    )
    PICTURE_EXTRACT = re.compile(r"\bPIC(?:TURE)?\s+(?:IS\s+)?([^\s.]+)", re.IGNORECASE)
    OCCURS_EXTRACT = re.compile(r"\bOCCURS\s+(\d+)(?:\s+TIMES)?", re.IGNORECASE)
    VALUE_EXTRACT = re.compile(
        r"\bVALUE\s+(?:IS\s+)?([^.]*?)(?=\s+(?:REDEFINES|PIC|OCCURS|USAGE|COMP|BINARY|PACKED|DISPLAY)\b|\s*$)",
        re.IGNORECASE,
    )

    def _parse_data_items(
        self, source: str, offset: int, all_lines: List[str]
    ) -> List[SimplifiedDataItem]:
        """Parse data items from a section."""
        items = []
        filler_counter = 0

        for match in self.DATA_ITEM.finditer(source):
            level = int(match.group(1))
            name = match.group(2).upper()

            # Handle FILLER items - give them unique internal names
            is_filler = False
            if name == "FILLER":
                filler_counter += 1
                name = f"FILLER${filler_counter}"
                is_filler = True

            # Extract clauses from the captured clause group
            clauses = match.group(3) if match.group(3) else ""

            # Extract individual clause values
            redefines_match = self.REDEFINES_EXTRACT.search(clauses)
            redefines = redefines_match.group(1).upper() if redefines_match else None

            picture_match = self.PICTURE_EXTRACT.search(clauses)
            picture = picture_match.group(1) if picture_match else None

            occurs_match = self.OCCURS_EXTRACT.search(clauses)
            occurs = int(occurs_match.group(1)) if occurs_match else None

            value_match = self.VALUE_EXTRACT.search(clauses)
            value = value_match.group(1).strip() if value_match else None

            # Calculate line number using absolute position in full source
            pos = offset + match.start()
            line_num = self._get_line_number_at_offset(all_lines, pos)

            items.append(
                SimplifiedDataItem(
                    level=level,
                    name=name,
                    picture=picture,
                    redefines=redefines,
                    occurs=occurs,
                    value=value,
                    line_number=line_num,
                    is_filler=is_filler,
                )
            )

        return items

    def _parse_procedure_division(
        self, source: str, offset: int, all_lines: List[str]
    ) -> SimplifiedProcedureDivision:
        """Parse the PROCEDURE DIVISION."""
        proc_div = SimplifiedProcedureDivision()

        # Pre-compute line offset map once for O(log n) line number lookups
        self._line_offset_map = self._build_line_offset_map(all_lines)

        # Find sections and paragraphs
        section_matches = list(self.SECTION_HEADER.finditer(source))
        paragraph_matches = list(self.PARAGRAPH_HEADER.finditer(source))

        # Filter paragraph matches that are actually section headers
        section_names = {m.group(1).upper() for m in section_matches}
        paragraph_matches = [
            m for m in paragraph_matches if m.group(1).upper() not in section_names
        ]

        if section_matches:
            # Parse orphan statements before first section
            first_section_start = section_matches[0].start()
            if first_section_start > 0:
                orphan_source = source[:first_section_start]
                proc_div.orphan_statements = self._extract_statements(
                    orphan_source, offset, all_lines
                )

            # Parse with sections
            for i, match in enumerate(section_matches):
                section_name = match.group(1).upper()
                section_start = match.end()

                if i + 1 < len(section_matches):
                    section_end = section_matches[i + 1].start()
                else:
                    section_end = len(source)

                section_source = source[section_start:section_end]
                section = self._parse_section(
                    section_name, section_source, offset + section_start, all_lines
                )
                proc_div.sections.append(section)
        else:
            # No sections, just paragraphs
            # Parse orphan statements before first paragraph
            if paragraph_matches:
                first_para_start = paragraph_matches[0].start()
                if first_para_start > 0:
                    orphan_source = source[:first_para_start]
                    proc_div.orphan_statements = self._extract_statements(
                        orphan_source, offset, all_lines
                    )

            for i, match in enumerate(paragraph_matches):
                para_name = match.group(1).upper()
                para_start = match.end()

                if i + 1 < len(paragraph_matches):
                    para_end = paragraph_matches[i + 1].start()
                else:
                    para_end = len(source)

                para_source = source[para_start:para_end]
                paragraph = self._parse_paragraph(
                    para_name, para_source, offset + para_start, all_lines
                )
                proc_div.paragraphs.append(paragraph)

        # Cleanup line offset map
        self._line_offset_map = None

        return proc_div

    def _parse_section(
        self, name: str, source: str, offset: int, all_lines: List[str]
    ) -> SimplifiedSection:
        """Parse a section."""
        section = SimplifiedSection(name=name)

        # Find paragraphs within section
        paragraph_matches = list(self.PARAGRAPH_HEADER.finditer(source))

        if paragraph_matches:
            # Parse statements before first paragraph
            pre_para_source = source[: paragraph_matches[0].start()]
            section.statements = self._extract_statements(
                pre_para_source, offset, all_lines
            )

            # Parse each paragraph
            for i, match in enumerate(paragraph_matches):
                para_name = match.group(1).upper()
                para_start = match.end()

                if i + 1 < len(paragraph_matches):
                    para_end = paragraph_matches[i + 1].start()
                else:
                    para_end = len(source)

                para_source = source[para_start:para_end]
                paragraph = self._parse_paragraph(
                    para_name, para_source, offset + para_start, all_lines
                )
                section.paragraphs.append(paragraph)
        else:
            # No paragraphs, just statements
            section.statements = self._extract_statements(source, offset, all_lines)

        return section

    def _parse_paragraph(
        self, name: str, source: str, offset: int, all_lines: List[str]
    ) -> SimplifiedParagraph:
        """Parse a paragraph."""
        paragraph = SimplifiedParagraph(name=name)
        paragraph.statements = self._extract_statements(source, offset, all_lines)
        return paragraph

    def _build_line_offset_map(self, all_lines: List[str]) -> List[int]:
        """Pre-compute character offsets for each line.

        Returns list where line_offsets[i] = character offset where line i+1 starts.
        Time: O(n) single pass, called once per parse.
        """
        offsets = [0]
        current_pos = 0
        for line in all_lines[:-1]:
            current_pos += len(line) + 1  # +1 for newline
            offsets.append(current_pos)
        return offsets

    def _get_line_number_at_offset(self, all_lines: List[str], char_offset: int) -> int:
        """Calculate the 1-based line number for a character offset in the original source.

        Args:
            all_lines: All source lines from the original file
            char_offset: Character offset from the beginning of the source

        Returns:
            1-based line number

        Uses pre-computed line offset map with binary search for O(log n) lookups
        when available, falls back to O(n) linear search otherwise.
        """
        # Use cached line offset map if available (O(log n) binary search)
        if hasattr(self, "_line_offset_map") and self._line_offset_map:
            line_num = bisect.bisect_right(self._line_offset_map, char_offset)
            return min(line_num, len(all_lines))

        # Fallback to linear search if map not available
        current_pos = 0
        for line_num, line in enumerate(all_lines, start=1):
            # Each line includes its newline character in the offset calculation
            line_length = len(line) + 1  # +1 for newline
            if current_pos + line_length > char_offset:
                return line_num
            current_pos += line_length
        # If we reach here, return the last line
        return len(all_lines)

    def _extract_statements(
        self, source: str, offset: int, all_lines: List[str]
    ) -> List[SimplifiedStatement]:
        """Extract modifying statements and their source variables from source."""
        statements = []

        # Statement patterns: (pattern, stmt_type, target_extractor, source_extractor)
        # source_extractor can be None if the statement doesn't read variables
        patterns = [
            (
                self.MOVE_STMT,
                "MOVE",
                self._extract_move_targets,
                self._extract_move_sources,
            ),
            (
                self.COMPUTE_STMT,
                "COMPUTE",
                self._extract_single_target,
                self._extract_compute_sources,
            ),
            (
                self.ADD_STMT,
                "ADD",
                self._extract_arithmetic_targets,
                self._extract_arithmetic_sources,
            ),
            (
                self.SUBTRACT_STMT,
                "SUBTRACT",
                self._extract_arithmetic_targets,
                self._extract_arithmetic_sources,
            ),
            (
                self.MULTIPLY_STMT,
                "MULTIPLY",
                self._extract_arithmetic_targets,
                self._extract_arithmetic_sources,
            ),
            (
                self.DIVIDE_STMT,
                "DIVIDE",
                self._extract_arithmetic_targets,
                self._extract_arithmetic_sources,
            ),
            (
                self.ACCEPT_STMT,
                "ACCEPT",
                self._extract_single_target,
                None,
            ),  # ACCEPT doesn't read
            (
                self.READ_STMT,
                "READ",
                self._extract_read_targets,
                None,
            ),  # READ doesn't read variables
            (
                self.INITIALIZE_STMT,
                "INITIALIZE",
                self._extract_multi_targets,
                None,
            ),  # INITIALIZE doesn't read
            (
                self.SET_STMT,
                "SET",
                self._extract_single_target,
                self._extract_set_sources,
            ),
            (
                self.STRING_STMT,
                "STRING",
                self._extract_single_target,
                self._extract_string_sources,
            ),
            (
                self.UNSTRING_STMT,
                "UNSTRING",
                self._extract_multi_targets,
                self._extract_unstring_sources,
            ),
            (
                self.INSPECT_STMT,
                "INSPECT",
                self._extract_single_target,
                None,
            ),  # INSPECT target is also read
            # Arithmetic with GIVING clause
            (
                self.ADD_GIVING_STMT,
                "ADD",
                self._extract_giving_target,
                self._extract_giving_sources,
            ),
            (
                self.SUBTRACT_GIVING_STMT,
                "SUBTRACT",
                self._extract_giving_target,
                self._extract_giving_sources,
            ),
            (
                self.MULTIPLY_GIVING_STMT,
                "MULTIPLY",
                self._extract_giving_target,
                self._extract_giving_sources,
            ),
            (
                self.DIVIDE_GIVING_STMT,
                "DIVIDE",
                self._extract_divide_giving_targets,
                self._extract_giving_sources,
            ),
            # WRITE FROM / REWRITE FROM - target is record, source is FROM variable
            (
                self.WRITE_FROM_STMT,
                "WRITE",
                self._extract_single_target,
                self._extract_from_source,
            ),
            (
                self.REWRITE_FROM_STMT,
                "REWRITE",
                self._extract_single_target,
                self._extract_from_source,
            ),
            # RETURN INTO - similar to READ INTO
            (
                self.RETURN_INTO_STMT,
                "RETURN",
                self._extract_read_targets,
                None,
            ),
            # MOVE CORRESPONDING
            (
                self.MOVE_CORR_STMT,
                "MOVE_CORRESPONDING",
                self._extract_corr_targets,
                self._extract_corr_sources,
            ),
        ]

        for pattern, stmt_type, target_extractor, source_extractor in patterns:
            for match in pattern.finditer(source):
                targets = target_extractor(match)
                sources = source_extractor(match) if source_extractor else []
                # Calculate actual line number using offset from original source
                char_pos = offset + match.start()
                line_num = self._get_line_number_at_offset(all_lines, char_pos)

                statements.append(
                    SimplifiedStatement(
                        statement_type=stmt_type,
                        text=match.group(0).strip(),
                        targets=targets,
                        sources=sources,
                        line_number=line_num,
                    )
                )

        # Extract read-only statements (DISPLAY, IF conditions, EVALUATE, etc.)
        self._extract_read_only_statements(source, offset, all_lines, statements)

        return statements

    def _extract_move_targets(self, match) -> List[str]:
        """Extract targets from MOVE statement."""
        targets_str = match.group(2)
        return self._split_variable_list(targets_str)

    def _extract_move_sources(self, match) -> List[str]:
        """Extract source variables from MOVE statement including subscripts."""
        source_str = match.group(1)
        # Single pass extraction from source
        sources = self._extract_all_variables_with_subscripts(source_str)

        # Also extract subscript variables from targets (they are read to determine position)
        target_str = match.group(2) if match.lastindex >= 2 else ""
        if target_str:
            # Only need subscript vars from target, not the target vars themselves
            sources.extend(self._extract_subscripts_from_text(target_str))

        # Deduplicate while preserving order
        seen = set()
        return [s for s in sources if not (s in seen or seen.add(s))]

    def _extract_single_target(self, match) -> List[str]:
        """Extract single target from statement."""
        target = match.group(1).strip()
        # Remove subscripts
        target = self._remove_subscript(target)
        return [target.upper()]

    def _extract_arithmetic_targets(self, match) -> List[str]:
        """Extract targets from arithmetic statements."""
        target = match.group(2).strip()
        target = self._remove_subscript(target)
        return [target.upper()]

    def _extract_arithmetic_sources(self, match) -> List[str]:
        """Extract sources from arithmetic statements (ADD/SUBTRACT/MULTIPLY/DIVIDE)."""
        source_str = match.group(1)
        # Single pass extraction from source
        sources = self._extract_all_variables_with_subscripts(source_str)

        # Also extract subscript variables from target
        target_str = match.group(2) if match.lastindex >= 2 else ""
        if target_str:
            sources.extend(self._extract_subscripts_from_text(target_str))

        # Deduplicate while preserving order
        seen = set()
        return [s for s in sources if not (s in seen or seen.add(s))]

    def _extract_read_targets(self, match) -> List[str]:
        """Extract targets from READ statement."""
        target = match.group(2).strip()
        target = self._remove_subscript(target)
        return [target.upper()]

    def _extract_multi_targets(self, match) -> List[str]:
        """Extract multiple targets from statement."""
        targets_str = match.group(1)
        return self._split_variable_list(targets_str)

    def _extract_compute_sources(self, match) -> List[str]:
        """Extract sources from COMPUTE statement (right side of =)."""
        # Group 2 contains the expression after the =
        expr = match.group(2) if match.lastindex >= 2 else ""
        # Single pass extraction from expression
        sources = self._extract_all_variables_with_subscripts(expr)

        # Also extract subscript variables from target
        target_str = match.group(1) if match.lastindex >= 1 else ""
        if target_str:
            sources.extend(self._extract_subscripts_from_text(target_str))

        # Deduplicate while preserving order
        seen = set()
        return [s for s in sources if not (s in seen or seen.add(s))]

    def _extract_set_sources(self, match) -> List[str]:
        """Extract source from SET statement."""
        full_text = match.group(0)
        # SET X TO Y - extract Y
        to_match = re.search(
            r"\bTO\s+([A-Za-z0-9][-A-Za-z0-9]*)", full_text, re.IGNORECASE
        )
        if to_match:
            return self._split_variable_list(to_match.group(1))
        return []

    def _extract_string_sources(self, match) -> List[str]:
        """Extract sources from STRING statement."""
        full_text = match.group(0)
        # STRING A B C INTO X - extract everything before INTO
        into_pos = full_text.upper().find(" INTO ")
        if into_pos >= 0:
            sources_part = full_text[7:into_pos]  # Skip "STRING "
            # Single pass extraction from source
            sources = self._extract_all_variables_with_subscripts(sources_part)

            # Also extract subscript variables from target
            target_part = full_text[into_pos:]
            sources.extend(self._extract_subscripts_from_text(target_part))

            # Deduplicate while preserving order
            seen = set()
            return [s for s in sources if not (s in seen or seen.add(s))]
        return []

    def _extract_unstring_sources(self, match) -> List[str]:
        """Extract source from UNSTRING statement."""
        full_text = match.group(0)
        # UNSTRING X INTO Y Z - X is the source
        unstring_match = re.match(
            r"\bUNSTRING\s+([A-Za-z0-9][-A-Za-z0-9]*)", full_text, re.IGNORECASE
        )
        if unstring_match:
            source = self._remove_subscript(unstring_match.group(1))
            if source.upper() not in self.COBOL_KEYWORDS:
                return [source.upper()]
        return []

    def _extract_giving_target(self, match) -> List[str]:
        """Extract target from arithmetic GIVING statement.

        For ADD/SUBTRACT/MULTIPLY A TO/FROM/BY B GIVING C, C is the target.
        """
        # Group 3 contains the GIVING target
        target = match.group(3).strip()
        target = self._remove_subscript(target)
        return [target.upper()]

    def _extract_divide_giving_targets(self, match) -> List[str]:
        """Extract targets from DIVIDE GIVING with optional REMAINDER.

        For DIVIDE A BY B GIVING Q REMAINDER R, both Q and R are targets.
        """
        targets = []
        # Group 3 contains the GIVING target
        giving_target = match.group(3).strip()
        giving_target = self._remove_subscript(giving_target)
        targets.append(giving_target.upper())

        # Group 4 contains the optional REMAINDER target
        if match.lastindex >= 4 and match.group(4):
            remainder_target = match.group(4).strip()
            remainder_target = self._remove_subscript(remainder_target)
            targets.append(remainder_target.upper())

        return targets

    def _extract_giving_sources(self, match) -> List[str]:
        """Extract sources from arithmetic GIVING statement.

        For ADD A TO B GIVING C, A and B are sources.
        For SUBTRACT A FROM B GIVING C, A and B are sources.
        """
        sources = []

        # Group 1 contains the first operand(s)
        if match.group(1):
            sources.extend(self._extract_all_variables_with_subscripts(match.group(1)))

        # Group 2 contains the second operand (TO/FROM/BY target that becomes source with GIVING)
        if match.lastindex >= 2 and match.group(2):
            sources.extend(self._extract_all_variables_with_subscripts(match.group(2)))

        # Also extract subscript variables from GIVING target
        if match.lastindex >= 3 and match.group(3):
            sources.extend(self._extract_subscripts_from_text(match.group(3)))

        # Extract subscript variables from REMAINDER target if present
        if match.lastindex >= 4 and match.group(4):
            sources.extend(self._extract_subscripts_from_text(match.group(4)))

        # Deduplicate while preserving order
        seen = set()
        return [s for s in sources if not (s in seen or seen.add(s))]

    def _extract_from_source(self, match) -> List[str]:
        """Extract source from WRITE FROM or REWRITE FROM statement.

        For WRITE REC FROM WS-BUF, WS-BUF is the source (read).
        """
        # Group 2 contains the FROM variable
        source_str = match.group(2).strip()
        sources = self._extract_all_variables_with_subscripts(source_str)

        # Also extract subscript variables from the record name (group 1)
        if match.group(1):
            sources.extend(self._extract_subscripts_from_text(match.group(1)))

        # Deduplicate while preserving order
        seen = set()
        return [s for s in sources if not (s in seen or seen.add(s))]

    def _extract_corr_targets(self, match) -> List[str]:
        """Extract target from MOVE CORRESPONDING statement.

        For MOVE CORR REC-A TO REC-B, REC-B is the target group.
        """
        # Group 2 contains the TO target
        target = match.group(2).strip()
        target = self._remove_subscript(target)
        return [target.upper()]

    def _extract_corr_sources(self, match) -> List[str]:
        """Extract source from MOVE CORRESPONDING statement.

        For MOVE CORR REC-A TO REC-B, REC-A is the source group (read).
        """
        # Group 1 contains the source group
        source_str = match.group(1).strip()
        sources = self._extract_all_variables_with_subscripts(source_str)

        # Also extract subscript variables from target
        if match.lastindex >= 2 and match.group(2):
            sources.extend(self._extract_subscripts_from_text(match.group(2)))

        # Deduplicate while preserving order
        seen = set()
        return [s for s in sources if not (s in seen or seen.add(s))]

    def _extract_variables_from_expression(self, expr: str) -> List[str]:
        """Extract variable names from an expression, filtering literals and keywords."""
        # Remove string literals in single pass using pre-compiled pattern
        expr_no_strings = self.STRING_LITERAL_PATTERN.sub(" ", expr)

        # Find all potential variable names using pre-compiled pattern
        variables = []
        for match in self.VARIABLE_PATTERN.finditer(expr_no_strings):
            var = match.group(1).upper()
            # Filter out COBOL keywords and literals
            if var not in self.COBOL_KEYWORDS and not self._is_literal_value(var):
                variables.append(var)
        return variables

    def _is_literal_value(self, text: str) -> bool:
        """Check if text is a literal value."""
        text = text.strip().upper()
        # Numeric literals
        if text.lstrip("-+").replace(".", "").isdigit():
            return True
        # Use class attribute instead of creating set each time
        return text in self.FIGURATIVE_CONSTANTS

    def _extract_all_variables_with_subscripts(self, text: str) -> List[str]:
        """Extract both plain variables and subscript variables in a single pass.

        This combines _extract_variables_from_expression and _extract_subscripts_from_text
        into a single efficient pass over the text.
        """
        # Remove string literals
        text_no_strings = self.STRING_LITERAL_PATTERN.sub(" ", text)

        variables = []
        # Single regex pass to find variables and their optional subscripts
        for match in self.VARIABLE_WITH_SUBSCRIPT_PATTERN.finditer(text_no_strings):
            var_name = match.group(1).upper()

            # Add the variable if it's not a keyword or literal
            if var_name not in self.COBOL_KEYWORDS and not self._is_literal_value(
                var_name
            ):
                variables.append(var_name)

            # If there are subscripts, extract them too
            subscript_str = match.group(2)
            if subscript_str:
                for sub_part in re.split(r"[,\s]+", subscript_str):
                    sub_part = sub_part.strip()
                    if sub_part and sub_part[0].isalpha():
                        sub_var = sub_part.upper()
                        if (
                            sub_var not in self.COBOL_KEYWORDS
                            and not self._is_literal_value(sub_var)
                        ):
                            variables.append(sub_var)

        return variables

    def _extract_subscripts_from_text(self, text: str) -> List[str]:
        """Extract all subscript variables from text containing subscripted references.

        Scans the entire text for patterns like VAR(INDEX) and extracts INDEX variables.
        """
        subscript_vars = []
        for var_match in re.finditer(r"[A-Za-z0-9][-A-Za-z0-9]*\s*\([^)]+\)", text):
            subscript_vars.extend(self._extract_subscript_variables(var_match.group(0)))
        return subscript_vars

    def _extract_perform_varying(
        self,
        source: str,
        offset: int,
        all_lines: List[str],
        statements: List[SimplifiedStatement],
    ) -> None:
        """Extract PERFORM VARYING statements."""
        for match in self.PERFORM_VARYING_STMT.finditer(source):
            sources = []

            # Extract from FROM, BY, and UNTIL in single pass each
            for group_idx in [2, 3, 4]:
                text = match.group(group_idx)
                if text:
                    sources.extend(self._extract_all_variables_with_subscripts(text))

            if sources:
                char_pos = offset + match.start()
                line_num = self._get_line_number_at_offset(all_lines, char_pos)
                # Deduplicate while preserving order
                seen = set()
                unique_sources = []
                for s in sources:
                    if s not in seen:
                        seen.add(s)
                        unique_sources.append(s)
                statements.append(
                    SimplifiedStatement(
                        statement_type="PERFORM_VARYING",
                        text=match.group(0).strip()[:100],
                        targets=[],
                        sources=unique_sources,
                        line_number=line_num,
                    )
                )

    def _extract_call_using(
        self,
        source: str,
        offset: int,
        all_lines: List[str],
        statements: List[SimplifiedStatement],
    ) -> None:
        """Extract CALL USING statements."""
        for match in self.CALL_STMT.finditer(source):
            using_clause = match.group(1)
            if not using_clause:
                continue

            # Single pass extraction of all variables including subscripts
            sources = self._extract_all_variables_with_subscripts(using_clause)

            if sources:
                char_pos = offset + match.start()
                line_num = self._get_line_number_at_offset(all_lines, char_pos)
                # Deduplicate while preserving order
                seen = set()
                unique_sources = [s for s in sources if not (s in seen or seen.add(s))]
                statements.append(
                    SimplifiedStatement(
                        statement_type="CALL",
                        text=match.group(0).strip()[:100],
                        targets=[],  # We track as read; modifications are external
                        sources=unique_sources,
                        line_number=line_num,
                    )
                )

    def _extract_if_full_condition(
        self,
        source: str,
        offset: int,
        all_lines: List[str],
        statements: List[SimplifiedStatement],
    ) -> None:
        """Extract all variables from IF conditions."""
        for match in self.IF_FULL_CONDITION.finditer(source):
            condition = match.group(1)
            # Single pass extraction of all variables including subscripts
            sources = self._extract_all_variables_with_subscripts(condition)

            if sources:
                char_pos = offset + match.start()
                line_num = self._get_line_number_at_offset(all_lines, char_pos)
                statements.append(
                    SimplifiedStatement(
                        statement_type="IF",
                        text=match.group(0).strip()[:100],
                        targets=[],
                        sources=list(dict.fromkeys(sources)),
                        line_number=line_num,
                    )
                )

    def _extract_evaluate_full(
        self,
        source: str,
        offset: int,
        all_lines: List[str],
        statements: List[SimplifiedStatement],
    ) -> None:
        """Extract all variables from EVALUATE statements including WHEN clauses."""
        for match in self.EVALUATE_FULL_STMT.finditer(source):
            sources = []

            # Subject(s) of EVALUATE - single pass extraction
            subject = match.group(1)
            if subject.strip().upper() != "TRUE":
                sources.extend(self._extract_all_variables_with_subscripts(subject))

            # Find the WHEN clauses after the EVALUATE subject
            # Search from after the subject match to find all WHEN clauses
            eval_start = match.start()
            # Find block end (END-EVALUATE or period)
            block_end_match = self.EVALUATE_BLOCK_END.search(source, match.end())
            if block_end_match:
                when_section = source[match.end() : block_end_match.start()]
            else:
                when_section = source[match.end() :]

            # Extract variables from WHEN clauses - single pass each
            for when_match in self.EVALUATE_WHEN_CLAUSE.finditer(when_section):
                when_value = when_match.group(1).strip()
                if when_value.upper() != "OTHER":
                    sources.extend(
                        self._extract_all_variables_with_subscripts(when_value)
                    )

            if sources:
                char_pos = offset + match.start()
                line_num = self._get_line_number_at_offset(all_lines, char_pos)
                statements.append(
                    SimplifiedStatement(
                        statement_type="EVALUATE",
                        text=match.group(0).strip()[:100],
                        targets=[],
                        sources=list(dict.fromkeys(sources)),
                        line_number=line_num,
                    )
                )

    def _extract_read_only_statements(
        self,
        source: str,
        offset: int,
        all_lines: List[str],
        statements: List[SimplifiedStatement],
    ) -> None:
        """Extract statements that only read variables (DISPLAY, IF, EVALUATE, PERFORM, CALL)."""
        # DISPLAY statements - single pass extraction
        for match in self.DISPLAY_STMT.finditer(source):
            sources = self._extract_all_variables_with_subscripts(match.group(1))
            if sources:
                char_pos = offset + match.start()
                line_num = self._get_line_number_at_offset(all_lines, char_pos)
                # Deduplicate while preserving order
                seen = set()
                unique_sources = [s for s in sources if not (s in seen or seen.add(s))]
                statements.append(
                    SimplifiedStatement(
                        statement_type="DISPLAY",
                        text=match.group(0).strip(),
                        targets=[],  # DISPLAY doesn't modify
                        sources=unique_sources,
                        line_number=line_num,
                    )
                )

        # Full IF conditions (captures all variables in the condition)
        self._extract_if_full_condition(source, offset, all_lines, statements)

        # Full EVALUATE with WHEN clauses
        self._extract_evaluate_full(source, offset, all_lines, statements)

        # PERFORM VARYING (loop FROM/BY/UNTIL variables)
        self._extract_perform_varying(source, offset, all_lines, statements)

        # PERFORM UNTIL (enable existing pattern)
        for match in self.PERFORM_UNTIL.finditer(source):
            full_text = match.group(0)
            until_match = re.search(
                r"\bUNTIL\s+(.+?)(?:\s*\.|END-PERFORM|$)", full_text, re.IGNORECASE
            )
            if until_match:
                # Single pass extraction
                sources = self._extract_all_variables_with_subscripts(
                    until_match.group(1)
                )
                if sources:
                    char_pos = offset + match.start()
                    line_num = self._get_line_number_at_offset(all_lines, char_pos)
                    # Deduplicate while preserving order
                    seen = set()
                    unique_sources = [
                        s for s in sources if not (s in seen or seen.add(s))
                    ]
                    statements.append(
                        SimplifiedStatement(
                            statement_type="PERFORM_UNTIL",
                            text=match.group(0).strip()[:100],
                            targets=[],
                            sources=unique_sources,
                            line_number=line_num,
                        )
                    )

        # CALL USING (parameters passed to called programs)
        self._extract_call_using(source, offset, all_lines, statements)

    def _split_variable_list(self, text: str) -> List[str]:
        """Split a list of variable names, filtering out COBOL keywords."""
        # Split on commas and whitespace, filter empties
        parts = re.split(r"[,\s]+", text)
        results = []
        for part in parts:
            part = part.strip()
            if part and part[0].isalpha():
                part = self._remove_subscript(part)
                upper_part = part.upper()
                # Filter out COBOL keywords
                if upper_part not in self.COBOL_KEYWORDS:
                    results.append(upper_part)
        return results

    def _remove_subscript(self, text: str) -> str:
        """Remove subscript from variable name."""
        paren_pos = text.find("(")
        if paren_pos >= 0:
            return text[:paren_pos].strip()
        return text.strip()

    def _extract_subscript_variables(self, text: str) -> List[str]:
        """Extract variables used as subscripts from a subscripted variable reference.

        Examples:
            "WS-TABLE(IND-1)" -> ["IND-1"]
            "WS-TABLE(IND-1, IND-2)" -> ["IND-1", "IND-2"]
            "WS-TABLE(IND-1 IND-2)" -> ["IND-1", "IND-2"]
            "WS-TABLE(1)" -> []
        """
        results = []
        paren_match = re.search(r"\(([^)]+)\)", text)
        if paren_match:
            subscript_content = paren_match.group(1)
            # Handle comma-separated and space-separated subscripts
            parts = re.split(r"[,\s]+", subscript_content)
            for part in parts:
                part = part.strip()
                if part and part[0].isalpha():
                    upper_part = part.upper()
                    if (
                        upper_part not in self.COBOL_KEYWORDS
                        and not self._is_literal_value(upper_part)
                    ):
                        results.append(upper_part)
        return results

    def _remove_subscript_with_extraction(self, text: str) -> tuple:
        """Remove subscript while extracting subscript variables.

        Returns:
            Tuple of (base_variable_name, list_of_subscript_variables)
        """
        subscript_vars = self._extract_subscript_variables(text)
        paren_pos = text.find("(")
        if paren_pos >= 0:
            return text[:paren_pos].strip(), subscript_vars
        return text.strip(), subscript_vars
